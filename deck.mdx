import { Appear, Image, Code, Notes, Head } from "mdx-deck";
import { FullScreenCode, SplitRight } from "mdx-deck/layouts";
import { CodeSurfer } from "mdx-deck-code-surfer";
import dracula from "prism-react-renderer/themes/dracula";
export { dark as theme } from "mdx-deck/themes";

<img width="100%" height="600px" style={{opacity: .3}}src="./img/Pacman.jpg"/>
<div style={{ position: 'absolute', top: '250px', top: '200px', fontSize: 100, left: 0, right: 0, margin: 'auto'}}>
    <div>Unit Testing</div>
    <div>Your Front End Code</div>
</div>

<Notes>(press *Option + P*) presenter mode</Notes>

---

<CodeSurfer 
  code={require("raw-loader!./snippets/aboutme.snippet")} 
  lang="json"
  showNumbers={false}
  dark={true}
  />;

<Notes>1) Read Priorities. 2) What do I say about Ramsey Solutions</Notes>

---

<div style={{ fontSize: 100 }}>
  <div>Some of the questions this talk will answer</div>
</div>
<div style={{ fontSize: 60, textAlign: "left" }}>
  <ul>
      <li>What is a unit test?</li>
      <li>Why should I test my code?</li>      
      <li>What are the Pros/Cons of unit tests?</li>
      <li>What is TDD, BDD, DDD?</li>
      <li>What is mock data?</li>
      <li>What else??????</li>      
  </ul>
</div>

---

<div style={{ fontSize: 100 }}>
  <div>What is a unit test?</div>
  <Appear>
    <div style={{ fontSize: 60 }}>
      UNIT TESTING is a level of software testing where individual units/
      components of software are tested.
    </div>
  </Appear>
</div>

---

<div style={{ fontSize: 100 }}>
  <div>What about TDD, BDD, and DDD?</div>
</div>
---

<div style={{ fontSize: 100 }}>
  <div>Test Driven Development</div>
  <Appear>
    <div style={{ fontSize: 60, textAlign: "left" }}>
      Boss: Can you make a function that adds 2 numbers?
    </div>
    <div style={{ fontSize: 60, textAlign: "left" }}>Me: Sure...</div>
  </Appear>
</div>

<Notes>
  TDD is a software development proess that relies on the repetition of a very
  short development cycle. Opinion: When your boss hands you a big project...
  say adding an additional page to you app with a lot of logic that your going
  to have to create. My thought is to create a unit test(that fails) create the
  function to pass the test and then create the next unit test etc etc...
</Notes>

---

<CodeSurfer 
  code={require("raw-loader!./snippets/addtest.snippet")} 
  title="Tests for Add Function"
  lang="javascript"
  showNumbers={true}
  dark={true}
      steps={[
    { notes: "These are the tests I would write for a simple Add function"},
    { lines: [1], notes: "Describe is helpful to define what function is being tested. More on that in a few minutes" }, 
    { range: [2, 4], notes: "I always start with the most straight forward test." },    
    { range: [6, 8], notes: "I assume we want this to work with a negative number?" },
    { range: [10, 13], notes: "Writing tests forces you to think about edge cases." }, 
    { range: [15, 18], notes: "When writing tests plan for as many use cases as you can think of." },
    { range: [20, 23], notes: "What about decimal values?" },
    { range: [25, 27], notes: "Probably not going to happen, but what about an empty string?" }
  ]}
  />;

---

<CodeSurfer 
  code={require("raw-loader!./snippets/addfunctionfp.snippet")} 
  lang="javascript"
  title="3 out of 6 is good enough right?"
  showNumbers={true}
  dark={true}
    steps={[
    { notes: "Looks like I'm half way there."},
    { range: [1, 4], notes: "Takes is to variables adds them together and returns an answer. Done!" },  
    { range: [7, 14], notes: "My easy tests are passing." },
    { range: [15, 18], notes: "I passed two values why the heck did it return \"12\"?" },
    { range: [19, 22], notes: "I'll admit this probably isn't likely, but it's better to have it covered just in case." },
    { range: [23, 26], notes: "That was easy to." },
    { range: [27, 30], notes: "Stupid strings!!!!!" },
  ]}
  />;

---

<CodeSurfer 
  code={require("raw-loader!./snippets/addfunctionsp.snippet")} 
  lang="javascript"
  title="6 out of 6 is even better!"
  showNumbers={true}
  dark={true}
    steps={[
    { notes: "I hate showing an add function that looks like this, but it's a real world scenario."},
    { range: [1, 4], notes: "Takes is to variables adds them together and returns an answer. Done!" },  
    { range: [7, 14], notes: "My easy tests are passing." },
    { range: [15, 18], notes: "I passed two values why the heck did it return \"12\"?" },
    { range: [19, 22], notes: "I'll admit this probably isn't likely, but it's better to have it covered just in case." },
    { range: [23, 26], notes: "That was easy to." },
    { range: [27, 30], notes: "Stupid strings!!!!!" },
  ]}
  />;

---

# How wide is the screen?

---

<CodeSurfer 
  code={require("raw-loader!./snippets/useeffect.snippet")} 
  lang="javascript"
  showNumbers={true}
  dark={true}
    steps={[
    { notes: "Let's get the width of the screen." },
    { range: [6, 12], notes: "This is a little intimidating. What the heck is going on?" },
    { range: [7, 7], notes: "Function to update the current width of the screen." },
    { range: [8, 8], notes: "Simple js event to listen for the screen to be resized." },    
    { range: [9, 11] , notes: "Event(s) you want to unmount." },
    { notes: "What would a class look like?." }
  ]}
  />;

<Notes>
In this example we are using useEffect to get the current width of the users screen.
CLICK!
At first glance useEffect looks confusing, but let's break down whats happening here.
CLICK!
First is a function to update the width of the users screen.
CLICK!
Next is a simple js eventListener that is firing this function each time it detects the screen width changing.
CLICK!
What's the return for? For anyone that has used subscriptions you know that once you are finished with a subscription you have to unsubscribe from them. That's exactly what we do in the return. Instead of window.removeEventListener this could have been a call to a function to unsubscribe fron an event. Another advantage of useEffect's is they do not block the browser from updating the screen, so this will make your app feel more responsive.

Think about what this would look like if this was a class. You would have componentDidMount() some logic and then componentDidUnmount() with logic to unsubscribe.

</Notes>

---

# What is useContext?

<Notes>
Add image to this slide?

Before we talk about what useContext is we need to talk about the context api. The context api is a way to pass data through your app without passing props multiple levels deep.
It can be a good alternative to redux when all your doing is passing data around.

</Notes>

---

<Notes>
Add image of star wars here!!!!!

</Notes>

---

<CodeSurfer 
  code={require("raw-loader!./snippets/usecontext.snippet")} 
  lang="javascript"
  showNumbers={true}
  dark={true}
    steps={[
    { notes: "Example of passing data to child component." },
    { range: [3, 3], notes: "Creating a context object...Okay what's that?" },
    { range: [10, 16], notes: "Set the value that is passed down to child components." },
    { range: [5, 8], notes: "Access data from the parent component." },
    { notes: "Imagine this broke out into individual files." }
  ]}
  />;

<Notes>
In this example we are using setContext to show how easily data can be passed from a parent to child component(s). If your not familiar with the context API or Redux this can be a little intimidating at first glance. I'm going to try to hit some of the high points, but check the docs for more detail on the context api.
CLICK!
createContext creates a context object. A context object is like a store for data. You can add data in one component and access it in another component. 
CLICK!
The parent component App will be where the value is set. 
CLICK!
Display will retrieved the value from the store. 
CLICK!
In the example this is all in 1 file, but if this would have been a production app I would have seperated this into 1 file for the context, 1 file for the App component and 1 file for the Display component. Remember I don't have to access the value in Display. I could have easily had another component nested inside Display that was accessing the value from App.

Opinion
I feel like this is one area where React has stole an idea from angular. I think one of the pain points of React has always been how to deal with passing data around and I feel l ike the context api was a great first step and this helps make it a little more accessible.

</Notes>

---

# Advanced Hooks

---

<Notes>
In this example we are using multiple setState's and useEffect. 
CLICK!
You can set setState to an initialValue. One example I have seen is declaring a variable initVal and using it for all instances of useState, then you can test for the initial value in your component to make sure it is initialized properly.
CLICK!
addEventlisteners 
CLICK!
Remember this get's fired when the component is unmounted.
CLICK!
In thie effect we are firing the event OnMount. If this is updating state why isn't it an infinite loop?
CLICK!
When you pass an empty array to useEffect it stops the effect from rerendering. If you had an array of numerous items you could pass a 2nd argument that say updates a single object going forward.

Opinion
I have to say I work in Angular all day, and we don't have console errors about memory leaks, but I'm impressed with the error messages that react emits when it detects a memory leak.

</Notes>

---

# What is a custom Hook?

---

# Important notes about hooks.

<div style={{ fontSize: 60, textAlign: "left" }}>
  <ul>
    <Appear>
      <li>Hooks can only be called from React function components</li>
      <li>Hooks must be called at the top level</li>
      <li>
        Hooks must run in the same order every time. (No conditional renders)
      </li>
    </Appear>
  </ul>
</div>

---

# Summary of Hooks

<div style={{ fontSize: 60, textAlign: "left" }}>
  <ul>
    <Appear>
      <li>Code is more readable.</li>
      <li>Easier to test.</li>
      <li>Faster in Prod(In Theory).</li>
      <li>Custom Hooks could be a game changer. I hate that term!</li>
    </Appear>
  </ul>
</div>

<Notes>
  Your code is more readable, because hooks allow us to break out our logic more
  cleanly and concisely. One of the side benefits of smaller components is it is
  a lot easier to test. Hooks are better optimez for minification, which in
  theory should reduce the bundle size and make it a little more performant. I
  don't think we quite understand the full potential of custom hooks. I've seem
  a few interesting ideas around custom hooks, but I don't think we fully
  understand what can be done yet. Last Point) Tell story about what we are
  doing with our project at work. (Refactoring certain areas ... hitting the
  growing pains). If your at that point with your app use hooks when you
  refactor, but I wouldn't refactor a prod app just to use hooks.
</Notes>

---

# Special Thanks

<div style={{ fontSize: 60, textAlign: "left" }}>
  <ul>
    <li>Kevin Old</li>
    <li>React Community</li>
    <li>Interactive Resources for bring food</li>
  </ul>
</div>

---

# Go make something great everyone!

<img width="100%" height="700px" src="./img/awesome.jpg" />
